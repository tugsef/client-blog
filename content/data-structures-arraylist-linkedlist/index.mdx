---
title: "Veri YapÄ±larÄ± ve Algoritmalar-2"
description: "Arraylist. Linkedlist ve KarÅŸÄ±laÅŸtÄ±rma"
image: "../../public/blogs/data-structures-and-algorithms/linkedlist-arraylist.png"
publishedAt: "2024-01-02"
updatedAt: "2024-01-02"
author: "Sefa DemirtaÅŸ"
isPublished: true
tags:
  - data structurecs
  - algorithms
  - veri yapilari
  - arraylist
  - linkedlist
---

## Linked Lists ğŸ”—

**"Linked List" (BaÄŸlÄ± Liste)**, bilgisayar bilimleri ve programlamada kullanÄ±lan bir veri yapÄ±sÄ±dÄ±r. Linked List, elemanlarÄ±n baÄŸlantÄ±lar (linkler) aracÄ±lÄ±ÄŸÄ±yla birbirine baÄŸlÄ± olduÄŸu bir veri yapÄ±sÄ±dÄ±r. Bu veri yapÄ±sÄ±, elemanlarÄ±n bellekte ardÄ±ÅŸÄ±k olarak yerleÅŸmediÄŸi, ancak her elemanÄ±n bir Ã¶nceki ve bir sonraki elemanÄ± iÅŸaret ettiÄŸi bir yapÄ±dÄ±r.

Temel olarak, bir linked list elemanlarÄ± ve bu elemanlarÄ±n birbirine baÄŸlantÄ±larÄ±ndan oluÅŸur. **Bir linked list'in temel bileÅŸenleri ÅŸunlardÄ±r:**

- **DÃ¼ÄŸÃ¼m (Node):**

Linked list'in temel birimi olan dÃ¼ÄŸÃ¼m, veriyi ve bir sonraki dÃ¼ÄŸÃ¼mÃ¼ iÅŸaret eden bir referansÄ± iÃ§erir.

- **BaÄŸlantÄ± (Link):**

DÃ¼ÄŸÃ¼mleri birbirine baÄŸlayan referanslardÄ±r. Her dÃ¼ÄŸÃ¼m, bir Ã¶nceki ve bir sonraki dÃ¼ÄŸÃ¼mÃ¼n referanslarÄ±nÄ± iÃ§erir.

**Linked List'in Ã§eÅŸitli tÃ¼rleri vardÄ±r. Ä°ki temel tÃ¼r ÅŸunlardÄ±r:**

1. **Tek YÃ¶nlÃ¼ Linked List (Singly Linked List):**

DÃ¼ÄŸÃ¼mler sadece bir sonraki dÃ¼ÄŸÃ¼mÃ¼ iÅŸaret eder. Yani, elemanlar tek bir yÃ¶nde hareket eder.

<p align="center">
  <Image
    src="/blogs/data-structures-and-algorithms/linked-list-data-singly.png"
    width="718"
    height="404"
    alt="Image"
    sizes="100vw"
  />
</p>

2. **Ã‡ift YÃ¶nlÃ¼ Linked List (Doubly Linked List):**

DÃ¼ÄŸÃ¼mler hem bir Ã¶nceki hem de bir sonraki dÃ¼ÄŸÃ¼mÃ¼ iÅŸaret eder. Bu, ileri ve geri yÃ¶nde hareket etmeyi saÄŸlar, ancak daha fazla bellek kullanÄ±r.

<p align="center">
  <Image
    src="/blogs/data-structures-and-algorithms/linked-data-doubly.png"
    width="718"
    height="404"
    alt="Image"
    sizes="100vw"
  />
</p>

```java title="Main.java" caption="Linked Lists"

package linkedlist;

import java.util.LinkedList;

public class Main {
	public static void main(String[] args) {
//		************************************************************************

//		Linkedlist = DÃ¼ÄŸÃ¼mleri 2 parÃ§a halinde saklar [veri + adres)
//                   DÃ¼ÄŸÃ¼mler ardÄ±ÅŸÄ±k olmayan bellektedir
//					 Ã–ÄŸeler iÅŸaretÃ§iler kullanÄ±larak baÄŸlanÄ±r

//								Tek BaÄŸlantÄ±lÄ± Liste
//						Node                 Node                 Node
//		            [data | adress] - > [data | adress] - > [data | adress]

//								Ã‡ift BaÄŸlantÄ±lÄ± Liste
//						     Node                         Node
//       		    [data | adress | data] < - > [data | adress | data]

//					Avantajlar?
//					1. Dinamik Veri YapÄ±sÄ± (Ã§alÄ±ÅŸÄ±rken gerekli belleÄŸi ayÄ±rÄ±r)
//					2. Insertion and Deletion of Nodes is easy. 0(1)
//					3. Yok/DÃ¼ÅŸÃ¼k bellek israfÄ±

//					Dezavantajlar?
//                  1. Daha fazla bellek kullanÄ±mÄ± (ek iÅŸaretÃ§i)
//					2. Ã–ÄŸelere rastgele eriÅŸim yok (indeks [i] yok)
//          		3. Ã–ÄŸelere eriÅŸmek/aramak daha fazla zaman alÄ±r. 0(n)
//					kullanÄ±r mÄ±?
//
//                  KullanÄ±mlar?
//					1. YÄ±ÄŸÄ±nlarÄ±/KuyruklarÄ± uygulayÄ±n
//					2. GPS navigasyonu
//					3. mÃ¼zik Ã§alma listesi

//		************************************************************************

		LinkedList<String> linkedlist = new LinkedList<String>();
		linkedlist.push("A");
		linkedlist.push("B");
		linkedlist.push("C");
		linkedlist.push("D");
		linkedlist. push("F");
		linkedlist.pop();

		linkedlist.offer ("A");
		linkedlist.offer("B");
		linkedlist.offer("C");
		linkedlist.offer("D");
		linkedlist.offer("F");
		linkedlist.pop();

		System.out.println(linkedlist.indexOf("F'"));
		linkedlist.add(4,"E");
		linkedlist.remove("E");
		System.out. println(linkedlist.peekFirst());
				System.out.println(linkedlist.peekLast());
				linkedlist.addFirst("0");
				linkedlist.addLast("G");
				String first = linkedlist.removeFirst();
				String last = linkedlist.removeLast();
				System.out. println(linkedlist);	}
}
```

## Dynamic Arrays ğŸŒ±

- AvantajlarÄ±:

  1. 0(1) Ã¶ÄŸelerine rastgele eriÅŸim
  2. Ä°yi referans konumu ve veri Ã¶nbelleÄŸi kullanÄ±mÄ±
  3. Kolay ekleme/silme

- DezavantajlarÄ±;
  1. Daha fazla hafÄ±zayÄ± boÅŸa harcar
  2. ElemanlarÄ±n kaydÄ±rÄ±lmasÄ± zaman alÄ±cÄ±dÄ±r 0(n)
  3. Diziyi geniÅŸletmek/daraltmak zaman alÄ±r 0(n)

<details cursor> 
<summary> <b>Dinamik Array Ã–rnek</b></summary>

```java title="DinamicArray.java" caption="Dinamik Array DinamicArray class"

package dinamicArray;

public class DinamicArray {

	int size;
	int capacity = 10;
	Object[] array;

	public DinamicArray() {
		this.array = new Object[capacity];
	}

	public DinamicArray(int capacity) {
		this.capacity = capacity;
		this.array = new Object[capacity];
	}

	// Yeni nesne ekler
	public void add(Object data) {

		// dizinin size capacity den bÃ¼yÃ¼k veya kÃ¼Ã§Ã¼k ise arrayin boyutunu artÄ±r.
		if (size >= capacity) {
			grow();
		}

		// array index = 0 dan baÅŸlar arrayin size elemanÄ±na eklenir yani son elemanÄ±
		// olarak eklenmiÅŸ olur
		array[size] = data;

		// Yeni size eklenen obje ile +1 artmÄ±ÅŸ olur
		size++;
	}

	// index si diziye nesne ekler
	public void insert(int index, Object data) {

		if (size >= capacity) {
			grow();
		}

		for (int i = size; i > index; i--) {
			array[i] = array[i - 1];
		}

		array[index] = data;
		size++;
	}

	// Verilen objeyi silmek iÃ§in
	public void delete(Object data) {

		for (int i = 0; i < size; i++) {
			if (array[i] == data) {
				for (int j = 0; j < size - i - 1; j++) {
					array[i + j] = array[i + j + 1];
				}
				array[size - 1] = null;
				size--;
				if (size > (int) (capacity / 3)) {
					shrink();
				}
				break;
			}

		}
	}

	// obje var ise objenin index sini yok isede -1 dÃ¶ndÃ¼rÃ¼r.
	public int search(Object data) {
		for (int i = 0; i < size - 1; i++) {
			if (array[i] == data) {
				return i;
			}
		}

		return -1;
	}

	// Dizimizin boyutunu geniÅŸletecek
	private void grow() {
		int newCapacity = (int) (capacity * 2);
		Object[] newArray = new Object[newCapacity];

		for (int i = 0; i < size; i++) {
			newArray[i] = array[i];
		}

		array = newArray;
		capacity = newCapacity;
	}

	// capacity azaltma
	public void shrink() {

		int newCapacity = (int) (capacity / 2);
		Object[] newArray = new Object[newCapacity];

		for (int i = 0; i < size; i++) {
			newArray[i] = array[i];
		}

		array = newArray;
		capacity = newCapacity;
	}

	// Array in elemanÄ± var mÄ± yokmu
	public boolean isEmpty() {
		return size == 0;
	}

	public String toString() {
		String string = "";
		for (int i = 0; i < capacity; i++) {
			string += array[i] + ", ";
		}

		if (string != "") {
			string = "[" + string.substring(0, (string.length() - 2)) + "]";
		} else {
			string = "[]";
		}

		return string;
	}
}
```

```java title="Main.java" caption="Dinamik Array Main class"

package dinamicArray;

public class Main {

	public static void main(String[] args) {

		DinamicArray dinamikArray = new DinamicArray(5);

		System.out.println("\narray");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());

		dinamikArray.add("A");
		dinamikArray.add("B");
		dinamikArray.add("C");
		dinamikArray.add("D");
		dinamikArray.add("E");

		System.out.println("\nadd metodu");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());

		System.out.println("\ninsert metodu");
		dinamikArray.insert(3,"X");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());

		System.out.println("\ndelete metodu");
		dinamikArray.delete("X");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());


		System.out.println("\narama iÅŸlemi");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());
		System.out.println("index: " + dinamikArray.search("B"));
		System.out.println("index: " + dinamikArray.search("H"));

		System.out.println("\ncapacity artÄ±rma metodu");
		dinamikArray.add("A");
		dinamikArray.add("B");
		dinamikArray.add("C");
		dinamikArray.add("D");
		dinamikArray.add("E");
		dinamikArray.add("F");
		System.out.println("capacity: " + dinamikArray.capacity);
		System.out.println("size: " + dinamikArray.size);
		System.out.println("array: " + dinamikArray.toString());
		System.out.println("empty: " + dinamikArray.isEmpty());


	}

}
```

```terminal title="Console" caption="Dinamik Array Console"

array
capacity: 5
size: 0
array: [null, null, null, null, null]
empty: true

add metodu
capacity: 5
size: 5
array: [A, B, C, D, E]
empty: false

insert metodu
capacity: 10
size: 6
array: [A, B, C, X, D, E, null, null, null, null]
empty: false

delete metodu
capacity: 5
size: 5
array: [A, B, C, D, E]
empty: false

arama iÅŸlemi
capacity: 5
size: 5
array: [A, B, C, D, E]
empty: false
index: 1
index: -1

capacity artÄ±rma metodu
capacity: 20
size: 11
array: [A, B, C, D, E, A, B, C, D, E, F, null, null, null, null, null, null, null, null, null]
empty: false
```

</details>

## LinkedLists vs ArrayLists ğŸ¤¼â€â™‚ï¸

Dinamik bir **array** oluÅŸturduk. Kendi dinamik arraylerimizi oluÅŸturabilirisniz. Java da ise **ArrayList** ve **LinkedList** kullanarak Ã¶nceden kodlanmÄ±ÅŸ dinamik arrayleri kullanabilirisiniz. Bu iki yÃ¶ntem verileri saklama ve arama noktasÄ±nda farklÄ± Ã¶zellikler sunar. Bu Ã¶zellikleri inceleyelim ve hangisisnin daha iyi olduÄŸunu bazÄ± basit testlerle anlamaya Ã§alÄ±ÅŸalÄ±m.

> Java sanal makinesinin zamanÄ±nÄ± nanosaniye cinsinden elde edeceÄŸiz. BildiÄŸimiz gibi kodlarÄ± satÄ±r satÄ±r okur. Bizde **baÅŸlangÄ±Ã§(startTime)**, **bitiÅŸ(endTime)** ve **geÃ§en zaman(elapsedTime)** kullanarak Ã§alÄ±ÅŸma zamanÄ±nÄ± elde edeceÄŸiz.

```java title="Main.java" caption="LinkedLists vs ArrayLists"

package arraylisiitvslinledlist;

import java.util.ArrayList;
import java.util.LinkedList;

public class Main {
	public static void main(String[] args) {
		LinkedList<Integer> linkedList = new LinkedList<Integer>();
		ArrayList<Integer> arrayList = new ArrayList<Integer>();

		long startTime;
		long endTime;
		long elapsedTime;

		for (int i = 0; i < 1000000; i++) {
			arrayList.add(i);
			linkedList.add(i);

		}

		startTime = System.nanoTime();

		//linkedList.get(0);
		//linkedList.get(500000);
		//linkedList.get(999999);
        //linkedList.remove(500000);
		linkedList.remove(0);

		endTime = System.nanoTime();
		elapsedTime = endTime - startTime;

		System.out.println("LinkedList:\t" + elapsedTime + "ns");

		startTime = System.nanoTime();

		//arrayList.get(0);
		//arrayList.get(500000);
		//arrayList.get(999999);
        //arrayList.remove(500000);
		arrayList.remove(0);

		endTime = System.nanoTime();
		elapsedTime = endTime - startTime;

		System.out.println("ArrayList:\t" + elapsedTime + "ns");

	}
}
```

> **SonuÃ§**
> Test sonuÃ§larÄ±mÄ±za baktÄ±ÄŸÄ±mÄ±z zaman **Arraylist** kullanÄ±mÄ±n **linkedlist** kullanÄ±mÄ±ndan daha esnek olduÄŸunu gÃ¶rebiliriz. **Arraylist** kullanÄ±rken aranan ve sileinen elemanÄ±n dizi iÃ§erisindeki yeri performansÄ± etkileyecektir.
> SonuÃ§ olarak bÃ¼yÃ¼k veri setleri, ekleme ve sileme baÄŸlantÄ±lÄ± iÅŸlemlerin yoÄŸun kullanÄ±lacaÄŸÄ± sistemlerde **linkedlist** kullanÄ±mÄ± daha iyi olacaktÄ±r.
