---
title: "Veri YapÄ±larÄ± ve Algoritmalar-1"
description: "Veri yapÄ±larÄ± ve Algoritma nedir? Stucks, Queue ve Priority Queues"
image: "../../public/blogs/data-structures-and-algorithms/stacks-queue-priority.png"
publishedAt: "2024-01-02"
updatedAt: "2024-01-02"
author: "Sefa DemirtaÅŸ"
isPublished: true
tags:
  - data structurecs
  - algorithms
  - veri yapÄ±larÄ±
  - stack
  - queue
---

## Veri YapÄ±larÄ± ve AlgoritmalarÄ± nedir? ğŸ“ˆ

Kod yazÄ±yoruz tamam ama arka plada neler oluyor. Bu veriler nasÄ±l oluyorda depolanÄ±yor neye gÃ¶re nasÄ±l sorularÄ±nÄ± kendimize sormuÅŸuzdur. Ä°ÅŸte bunun cevabÄ±nÄ± bende merak ettim ve size bir yazÄ± serisi oluÅŸturdum. Keyifli okumalar.

**Veri YapÄ±larÄ±:** Veri yapÄ±larÄ±, bilgisayar programlarÄ±nda veri elemanlarÄ±nÄ± dÃ¼zenlemek, depolamak ve yÃ¶netmek iÃ§in kullanÄ±lan yapÄ±sal organizasyonlardÄ±r. Bu yapÄ±lar, verinin etkili bir ÅŸekilde iÅŸlenmesini saÄŸlamak, hÄ±z ve bellek kullanÄ±mÄ± gibi performans faktÃ¶rlerini optimize etmek amacÄ±yla tasarlanÄ±r. Veri yapÄ±larÄ±, Ã¶rneÄŸin **diziler(Arraylist)**, **listeler(Linkedlist)**, **aÄŸaÃ§lar(Tree Data Structure)**, **grafikler**, **kuyruklar(Queues)** ve **yÄ±ÄŸÄ±nlar(stacks)** gibi Ã§eÅŸitli tiplerde olabilir.

**Algoritmalar:** Algoritmalar, belirli bir problemi Ã§Ã¶zmek veya belirli bir gÃ¶revi gerÃ§ekleÅŸtirmek iÃ§in adÄ±m adÄ±m talimatlar iÃ§eren mantÄ±ksal bir sÄ±radÄ±r. Algoritmalar, genellikle bir giriÅŸi alÄ±r, belirli bir iÅŸlemler dizisini uygular ve bir Ã§Ä±kÄ±ÅŸ Ã¼retir. Algoritmalar, veri yapÄ±larÄ± Ã¼zerinde iÅŸlem yaparak, bilgiyi dÃ¼zenleme, sÄ±ralama, arama, ekleme veya silme gibi Ã§eÅŸitli gÃ¶revleri gerÃ§ekleÅŸtirmek iÃ§in kullanÄ±lÄ±r.

Ã–zetle, veri yapÄ±larÄ± veriyi dÃ¼zenlemek ve depolamak iÃ§in kullanÄ±lÄ±rken, algoritmalar belirli bir gÃ¶revi gerÃ§ekleÅŸtirmek iÃ§in adÄ±m adÄ±m talimatlar iÃ§erir. Ä°kisi de birlikte kullanÄ±larak bilgisayar programlarÄ±nÄ±n etkili bir ÅŸekilde tasarlanmasÄ± ve uygulanmasÄ± saÄŸlanÄ±r.




## Stacks ğŸ“š

**Stack (yÄ±ÄŸÄ±n)**, bilgisayar bilimleri ve programlamada yaygÄ±n olarak kullanÄ±lan bir veri yapÄ±sÄ±dÄ±r. YÄ±ÄŸÄ±n, verilerin belirli bir sÄ±rayla depolandÄ±ÄŸÄ± ve Ã§Ä±kartÄ±ldÄ±ÄŸÄ± bir veri yapÄ±sÄ±dÄ±r. YÄ±ÄŸÄ±nlar genellikle **Last In, First Out (LIFO)** prensibiyle Ã§alÄ±ÅŸÄ±rlar, yani en son eklenen eleman en Ã¶nce Ã§Ä±kar.



```java title="Main.java' caption='Stacks Veri YapÄ±sÄ±"

package stacks;

import java.util.Stack;

public class Main {

	public static void main(String[] args) {

//	   ************************************************************************

// 	   Stack = LIFO ilk giren son Ã§Ä±kar
//         	   bir tÃ¼r dikey kule ÅŸeklinde sÄ±ralanÄ±r.

//         	   push() listenin tonuna elemen ekler
//        	   pop() dizinin son elemanÄ±nÄ± seÃ§er ve diziden silinir.
//         	   peek() dizinin son elemanÄ±nÄ± alÄ±r. ElemanÄ± silmez
//		   	   empty() dizi boi ise true, dolu ise false dÃ¶ner

//	   ************************************************************************

		Stack<String> stack = new Stack<String>();

//		System.out.println(stack.empty());

		stack.push( "Minecraft");
		stack.push("Skyrim");
		stack.push ("DOOM");
		stack.push ("Borderlands");
		stack.push ("'FFVII");
//		System.out.println(stack.empty());

		  stack.pop();


	   String myFavGame = stack.peek();
	   System.out.println(myFavGame);

	   if(stack.empty()==true)
		   System.out.println("List BoÅŸ");

//	   ************************************************************************

		// Nerelerde kullanÄ±lÄ±r.
		// 1. Metin editÃ¶rlerindeki geri/ileri(undo/redo) Ã¶zellikleri
		// 2. TarayÄ±cÄ± geÃ§miÅŸinde ileri/geri(back/forward)
		// 3. Geri izleme algoritmalarÄ± (maze, file directories)
		// 4. Calling functions

//	   ************************************************************************
	}
}
```

## Queues ğŸŸï¸


**Kuyruk (Queue)**, bilgisayar bilimleri ve programlamada kullanÄ±lan bir veri yapÄ±sÄ±dÄ±r. Kuyruk, verilerin belirli bir sÄ±rayla eklenip Ã§Ä±kartÄ±ldÄ±ÄŸÄ± bir yapÄ±dÄ±r ve genellikle First-In, First-Out (FIFO) prensibiyle Ã§alÄ±ÅŸÄ±r. Yani, kuyruÄŸa ilk eklenen eleman, kuyruktan ilk Ã§Ä±kartÄ±lan elemandÄ±r.

**KuyruklarÄ±n temel iki iÅŸlemi vardÄ±r:**

**Enqueue (Ekleme):**

Yeni bir elemanÄ± kuyruÄŸa ekler. Bu iÅŸlem kuyruÄŸun sonunda gerÃ§ekleÅŸir.

**Dequeue (Ã‡Ä±kartma):**

KuyruÄŸun baÅŸÄ±ndaki elemanÄ± Ã§Ä±kartÄ±r. Bu iÅŸlem kuyruÄŸun baÅŸÄ±nda gerÃ§ekleÅŸir.
Bu iki temel iÅŸlem, kuyruklarÄ±n verileri sÄ±ralÄ± bir ÅŸekilde yÃ¶netmelerini saÄŸlar. Kuyruklar genellikle iÅŸlemleri sÄ±rayla gerÃ§ekleÅŸtirmek ve talepleri belirli bir sÄ±rayla iÅŸlemek amacÄ±yla kullanÄ±lÄ±r.

<p align="center">
  <Image
    src="/blogs/data-structures-and-algorithms/collection-queue.png"
    width="718"
    height="404"
    alt="Image"
    sizes="100vw"
  />
</p>

```java title="Main.java" caption="Queues Veri YapÄ±sÄ±"

package queue;

import java.util.LinkedList;
import java.util.Queue;

public class Main {

    public static void main(String[] args) {


       // ****************************************************************************

       // Queue = FIFO veri yapÄ±sÄ±dÄ±r. First-In First-Out(Ä°lk giren - ilk Ã§Ä±kar)
       //         DoÄŸrusal bir veri yapsÄ±dÄ±r.
       //
       //         add() = enqueue, offer()
       //         remove() = dequeue, poll()
       //         size() = listenin eleman sayÄ±sÄ±nÄ± veririr
       //         isEmpty() = Dizi boÅŸ mu dolumu? BoÅŸ isr true dolu ise false dÃ¶ne

       // **********************************\*\*\*\***********************************

    	Queue<String> queue = new LinkedList<String>();
    	queue. offer ("Karen");
    	queue.offer("Chad");
    	queue. offer ("Steve");
    	queue.offer("Harold");


    	System.out.println(queue.contains(()));
    	System.out.println(queue.poll());
    	System.out.println(queue.poll());

    	System.out.println(queue.size());

        // **********************************\*\*\*\***********************************

        // 1. Klavye ArabelleÄŸi (harfler basÄ±lma sÄ±rasÄ±na gÃ¶re ekranda gÃ¶rÃ¼nmelidir)
        // 2. YazÄ±cÄ± SÄ±rasÄ± (YazdÄ±rma iÅŸleri sÄ±rasÄ±yla tamamlanmalÄ±dÄ±r)
        // 3. BaÄŸlantÄ±lÄ± Listelerde, Ã–ncelik SÄ±ralarÄ±nda, GeniÅŸlik Ã¶ncelikli aramada kullanÄ±lÄ±r

        // **********************************\*\*\*\***********************************
}
}
```

## Priority Queues ğŸ¥‡


**Ã–ncelikli Kuyruklar (Priority Queues)**, standart kuyruk yapÄ±larÄ±ndan farklÄ± olarak, her elemana bir Ã¶ncelik deÄŸeri atanabilen ve Ã¶ncelik deÄŸeri yÃ¼ksek olan elemanlarÄ±n Ã¶ncelik dÃ¼zeyine gÃ¶re iÅŸlemlerin gerÃ§ekleÅŸtiÄŸi veri yapÄ±larÄ±dÄ±r. Yani, Ã¶ncelikli kuyruklar, elemanlarÄ±n sadece sÄ±rayla deÄŸil, aynÄ± zamanda **Ã¶nceliklerine gÃ¶re** de sÄ±ralandÄ±ÄŸÄ± bir yapÄ±dÄ±r.

**Ã–ncelikli kuyruklarÄ±n temel iÅŸlemleri ÅŸunlardÄ±r:**

**Ekleme (Enqueue):**

Yeni bir elemanÄ± kuyruÄŸa eklerken, bu elemana bir Ã¶ncelik deÄŸeri de atanÄ±r.
Ã‡Ä±kartma (Dequeue):

Kuyruktan Ã§Ä±kartma iÅŸlemi sÄ±rasÄ±nda, en yÃ¼ksek Ã¶nceliÄŸe sahip eleman Ã¶ncelikli olarak seÃ§ilir ve kuyruktan Ã§Ä±kartÄ±lÄ±r.
Ã–ncelikli kuyruklarÄ±n kullanÄ±m alanlarÄ± ÅŸunlarÄ± iÃ§erebilir:

```java title="Main.java" caption="Priority Veri YapÄ±sÄ±"

package priorityQueue;

import java.util.Collections;
import java.util.PriorityQueue;
import java.util.Queue;

public class Main {
	public static void main(String[] args) {

//	************************************************************************

//	Priority Queue= FIFO veri yapÄ±sÄ±dÄ±r. First-In First-Out(Ä°lk giren - ilk Ã§Ä±kar).
//					Ã–ncelik sÄ±rasÄ±na gÃ¶re sÄ±ralama
//
//	        DoÄŸrusal bir veri yapsÄ±dÄ±r.
//
//			add       = enqueue, offer()
//			remove    = dequeue, poll()
//	        size()    = listenin eleman sayÄ±sÄ±nÄ± veririr
//			isEmpty() = Dizi boÅŸ mu dolumu? BoÅŸ isr true dolu ise false dÃ¶ner
//			contains()= Objenin dizide olup olmadÄ±ÄŸÄ±nÄ± kontontrol eder var ise tru yok ise false dÃ¶ner

//	************************************************************************

		Queue<Double> queue = new PriorityQueue<>(Collections.reverseOrder());
		Queue<String> queueStr = new PriorityQueue<>(Collections.reverseOrder());

		queue.offer(3.0);
		queue.offer(2.5);
		queue.offer(4.0);
		queue.offer(1.5);
		queue.offer(2.0);

		while (!queue.isEmpty()) {
			System.out.println(queue.poll());

		}
		System.out.println("----------------------------------");
		queueStr.offer("A");
		queueStr.offer("D");
		queueStr.offer("E");
		queueStr.offer("C");
		queueStr.offer("B");

		while (!queueStr.isEmpty()) {
			System.out.println(queueStr.poll());

		}
	}
}
```

```terminal caption='Console'

4.0
3.0
2.5
2.0
1.5
E
D
C
B
A
```