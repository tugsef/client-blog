---
title: "Veri Yapıları ve Algoritmalar-3"
description: "Veri yapıları ve Algoritma nedir? Stucks, Queue ve Priority Queues"
image: "../../public/blogs/data-structures-and-algorithms/big-o-notion.png"
publishedAt: "2024-01-02"
updatedAt: "2024-01-02"
author: "Sefa Demirtaş"
isPublished: true
tags:
  - data structurecs
  - algorithms
  - veri yapilari
  - big O notation
---

## Big O notation 📈

> **"Veri büyüdükçe kod nasıl yavaşlar?"**

- Veri miktarı arttıkça bir algoritmanın performansını açıklar.
- Makineden bağımsız (tamamlanmaya kalan adım sayısı)
- Daha küçük işlemleri yoksay *0(n;+ 1) -> 0(n)*
- <p align="center">
    <Image src="/blogs/data-structures-and-algorithms/big-o-notion.svg" width="718" height="404" alt="Image" sizes="100vw"
    />
  </p>
  <p align="center">
   <Image src="/blogs/data-structures-and-algorithms/big-o-notion-to-compore.png" width="718" height="404" alt="Image" sizes="100vw"
    />
   
  </p>
     **Örnek**
    ***n=*** tekrar miktarı

  - O(1)
  - O(n)
  - O(log)
  - O(n²)
  

- ***O(n)* linear time**
  Bu örnekte bir dizinin elemanının teker teker toplanması örneği verilmiştir. Bu örnekte **n** sayısının miktarı kadar işlen gerçekleşecektir. Yani - **Big O notation**= **O(n)** dir.

  ```java title="Main.java" caption="0(n) linear time"

  int addUp(int n){
  int sum = 0;
  for(int i = 0; i ‹= n; i++) {
  sum += i;
  ｝
  return sum;
  }
  }
  ```

- ***O(1)* constant time**

***n*** **0** dan **n** kadar sayıları toplamak istersek daha önce doğruluğu kanıtlanmış bir formül kullanırsak işlem sayısı **3** olacaktır. Büyük işlemler dikkate alındığında **1+2** **2** sayısı tekrarın sayısına büyük bir etki etmeyeceğinden.

- **Big O notation** = **O(1)** dir.

```java title="Main.java" caption=" O(1) constant time"

int addUp(int n){
int sum = n * (n + 1) / 2;
return sum;
}
```
